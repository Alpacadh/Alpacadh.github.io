---
layout: post
title:  "寒假三场训练JKL三题的题解"
date:   2019-1-31 22:00:00 +0800
tags: ACM
color: rgb(90,90,90)
cover: '../assets/IMG_3537.JPG'
---
>first
# J-vector的使用(The Blocks Problem UVA 101)

## 题意  ：

从左到右有n个木块，分别编号为0~n-1，给了如下四种操作并模拟：(关键就是对这四种操作的理解)

- **move a onto b：把a和b上方的木块全部归位，然后把a放在b上面。**
- **move a over b：把a上方的木块全部归位，然后把a放在b所在木块堆的顶部。**
- **pile a onto b：把b上方的木块全部归位，然后把a及上面的木块整体放在b上面。**
- **pile a over b：把a及上面的木块整体放在b所在木块堆的顶部。**

## 解题思路：

- 首先对题中给的四种操作进行分析，可以发现其实这四种操作可以归简为两大操作：

  :one: **把某个木块上面的木块全部归回原位**；

  :two:**把某个木块及它上面的木块整体移动到另一个木块堆的顶部**。

  (根据题目要求若操作的两个木块本就在一堆则此操作无效。）

  在进行这些操作我们还需要进行的一个步骤就是去寻找这些木块当前的位置，包括知道在哪个木块上，且在这个木块上的第几个（高度）。最后就是对这些操作进行代码实现。

  1、对于寻找位置操作，因为范围较小，所以可以逐个遍历去寻找查找值所在木块及其高度。因为要返回两个值，所以可以利用引用来获取。

  2、对于将某个木块上面的木块还原到初始位置操作，可以找到该木块的高度，然后把它高度以上的木块全部push_back到vector[当前木块]的后面。

  3、对于将某个木块及其上面的木块移动到另一个木块的顶部操作，和操作2比较相像，找到该木块后，将该木块push_back到另一个木块的后面。

## 代码：

```c++
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
char s1[5],s2[5];
vector<int>q[26];
int n;
void poss(int a,int &pos,int &h)//&为引用 若不加则无法正确传值。
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<q[i].size();j++)
        {
            if(q[i][j]==a)
            {
                pos=i;
                h=j;
                return;
            }
        }
    }
}
void move1(int pos,int h)//将某个木块上面的木块还原到初始位置
{
    int i=h+1;
    while(i!=q[pos].size())
    {
        int top=q[pos][i];
        q[top].push_back(top);
        q[pos].erase(q[pos].begin()+i);
    }

}
void move2(int apos,int ah,int bpos)//将某个木块及其上面的木块移动到另一个木块的顶部
{
    int i=ah;
    while(i!=q[apos].size())
    {
        int temp=q[apos][i];
        q[bpos].push_back(temp);
        q[apos].erase(q[apos].begin()+i);
    }

}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        q[i].push_back(i);
    while(scanf("%s",s1))
    {
        int a,b,ah,bh,apos,bpos;
        if(s1[0]=='q')
            break;
        else if(s1[0]=='m')
        {
            scanf("%d",&a);
            scanf("%s",s2);
            if(s2[1]=='n')
            {
                scanf("%d",&b);
                poss(a,apos,ah);
                poss(b,bpos,bh);
                if(apos==bpos)
                    continue;
                move1(apos,ah);
                move1(bpos,bh);
                move2(apos,ah,bpos);
            }
            else
            {
                scanf("%d",&b);
                poss(a,apos,ah);
                poss(b,bpos,bh);
                if(apos==bpos)
                    continue;
                move1(apos,ah);
                move2(apos,ah,bpos);
            }
        }
        else
        {
            scanf("%d",&a);
            scanf("%s",s2);
            if(s2[1]=='n')
            {
                scanf("%d",&b);
                poss(a,apos,ah);
                poss(b,bpos,bh);
                if(apos==bpos)
                    continue;
                move1(bpos,bh);
                move2(apos,ah,bpos);
            }
            else
            {
                scanf("%d",&b);
                poss(a,apos,ah);
                poss(b,bpos,bh);
                if(apos==bpos)
                    continue;
                move2(apos,ah,bpos);
            }
        }
    }
    for(int i=0;i<n;i++)
    {
        printf("%d:",i);
        int len=q[i].size();
        for(int j=0;j<len;j++)
        {
            printf(" %d",q[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```





# K-DFS(Oil Deposits HDU 1241/UVA 572) 

## 题意：

- 给一个N x M的矩阵，在这个矩阵*表示不是油田（无效），@表示油田（有效），并且在@的周围有另一个@就把它们视为一片油田，最后问这个矩阵中有多少片油田。

## 解题思路：

- 如题目提示的，这道题用DFS去搜索有多少片油田，需要注意的是@的周围是指它的八个方向（上、下、左、右、左上、左右、右下、右上）然后去依次遍历看此地是否访问过且是油田，若是则DFS它周围是否存在油田，若存在则标记一下该点（避免重复访问），然后再DFS该点，直到这一片油田周围没有油田，然后计数加一。

## 代码:

```c++
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=150;
char s[N][N];
int vis[105][105];
int dx[8]={1,0,-1,1,-1,1,0,-1};
int dy[8]={1,1,1,0,0,-1,-1,-1};
void dfs(int n,int m,int x,int y)
{
    for(int i=0;i<8;i++)
    {
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(s[xx][yy]!='@'||vis[xx][yy]==1||xx<0||xx>=n||yy<0||yy>=m)//判断该点是否合法
        {
            continue;
        }
        vis[xx][yy]=1;
        dfs(n,m,xx,yy);
    }
}
int main()
{
    int n,m;
    while(~scanf("%d%d",&n,&m))
    {
        if(n==0&&m==0)
            break;
        memset(vis,0,sizeof(vis));
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                cin>>s[i][j];
            }
        }
        int sum=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                if(s[i][j]=='@'&&vis[i][j]==0)
                {
                    vis[i][j]=1;
                   	sum++;
                    dfs(n,m,i,j);
                }
            }
        }
        printf("%d\n",sum);
    }
    return 0;
}
```



# L-stack的使用(Parentheses Balance  UVA 673)

## 题意：

- 给出两种括号()，[]，然后给出三种合法的包含该括号字符串规则，问有给出的字符串是否合法。若合法则输出Yes，不合法则输出No。

## 解题思路：

先看一下给出的三种合法规则：

- 空字符合法。
- ​如果A、B合法则AB合法。即( ) [ ]合法
- ​​ 如果A合法则(A)和[A]合法。即( [ ] )合法

通过这三个合法规则可以知道，如果出现 ] 或 ) 则它前面必然是 [ 或者 (，如果不是则该字符串一定不合法，再综合一下空字符串的特殊情况就可以。

具体做法：遍历字符串，遇到 ( , [ 直接用栈push进去就行，遇到 ) , ] 就取出栈顶元素看是否与 ), ] 匹配 ，若匹配则删除栈顶元素继续遍历，不匹配就break跳出循环，最后判定栈是否为空。关于特殊情况当遇到 ) ,]，栈为空时，把它push进栈然后break循环。然后就是对于空字符串的判定，如果是string用getline(cin,string名)，是char就用gets(数组名)，注意在输入测试样例组数后加个getchar()来缓冲掉空格避免被getline或者gets读入。

## 代码：

```c++
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=205;
int main()
{
    int t;
    scanf("%d",&t);
    string s;
    getchar();
    while(t--)
    {
        getline(cin,s);
        stack<char>q;
        if(s=="\0")
        {
            printf("Yes\n");
            continue;
        }
        int len=s.size();//得到string的长度 若是char型 则用strlen(字符数组名)
        for(int i=0;i<len;i++)
        {
            if(s[i]=='('||s[i]=='[')
            {
                q.push(s[i]);
            }
            else if(q.empty())
            {
                q.push(s[i]);
                break;
            }
            else
            {
                char top=q.top();
                if((s[i]==')'&&top=='(')||(s[i]==']'&&top=='['))
                {
                    q.pop();
                }
                else
                    break;
            }

        }
        if(q.empty())
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}

```

